Nice â€” this is a very common UI gotcha in React Native. Iâ€™ll answer each question briefly, then show a correct, copy-pasteable App.js pattern (Expo) that fixes the issues and explains why.
Short answers (quick)
Yes, position: 'absolute' is correct for a floating button â€” itâ€™s the right approach.
Place the FAB outside scrolling containers (i.e. as a sibling of the ScrollView) so it doesnâ€™t scroll or get clipped.
Use both zIndex and elevation: zIndex affects stacking on iOS; on Android the elevation value mostly controls draw order. Use high values for both.
Correct pattern: root container flex:1, put ScrollView or content first, then render the FAB as a last child positioned absolute (top/right/left/bottom). Ensure parents donâ€™t have overflow: 'hidden' that would clip it.
Common reasons your button was invisible
Parent container had overflow: 'hidden' or a smaller size, clipping the absolute child.
FAB was inside the ScrollView so it scrolled out of view or got occluded by other elements.
Low elevation on Android or zIndex not set/recognized.
The parent didnâ€™t use flex: 1, so absolute offsets didn't behave as expected.
SafeAreaView on some devices/policies may change layout â€” but you can keep FAB inside SafeAreaView as long as itâ€™s a sibling of the scrollable content (not a child of the ScrollView).
Corrected Example (Expo / React Native)
This example shows a header, a scrollable content area, and a floating robot button that stays in the top-left and remains visible while scrolling. It includes the chat modal opening logic.
Copy code
Jsx
// App.js (Expo / React Native)
import React, { useState } from "react";
import {
  SafeAreaView,
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Modal,
  Platform,
} from "react-native";

export default function App() {
  const [chatOpen, setChatOpen] = useState(false);

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.headerText}>My App</Text>
      </View>

      {/* Scrollable content */}
      <ScrollView contentContainerStyle={styles.contentContainer}>
        {/* lots of example content to allow scrolling */}
        {Array.from({ length: 30 }).map((_, i) => (
          <View key={i} style={styles.card}>
            <Text>Item #{i + 1}</Text>
          </View>
        ))}
      </ScrollView>

      {/*
        Floating button must be a sibling of ScrollView (so it doesn't scroll)
        and should be rendered after other children so it is on top.
      */}
      <TouchableOpacity
        activeOpacity={0.85}
        style={styles.floatingButton}
        onPress={() => setChatOpen(true)}
      >
        <Text style={styles.floatingButtonText}>ðŸ¤–</Text>
      </TouchableOpacity>

      {/* Chat modal */}
      <Modal
        visible={chatOpen}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setChatOpen(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.chatModal}>
            <Text style={{ fontSize: 18, marginBottom: 12 }}>Chat</Text>
            <Text style={{ color: "#666" }}>AI chat goes hereâ€¦</Text>

            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setChatOpen(false)}
            >
              <Text style={{ color: "#fff" }}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  // root container must be flex:1
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },

  header: {
    height: 56,
    borderBottomWidth: 1,
    borderBottomColor: "#eee",
    justifyContent: "center",
    paddingHorizontal: 16,
  },
  headerText: { fontSize: 18, fontWeight: "600" },

  contentContainer: {
    padding: 16,
    paddingBottom: 140, // ensure content not hidden behind FAB if bottom placed
  },

  card: {
    height: 80,
    backgroundColor: "#fafafa",
    borderRadius: 8,
    marginBottom: 12,
    justifyContent: "center",
    paddingHorizontal: 12,
  },

  /* Floating button */
  floatingButton: {
    position: "absolute",
    top: 12,
    left: 12,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: "#10B981",
    justifyContent: "center",
    alignItems: "center",

    // iOS shadow
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,

    // Android elevation (also helps stacking on Android)
    elevation: 10,

    // zIndex helps on iOS â€” high value so it's above other elements
    zIndex: 9999,
  },
  floatingButtonText: {
    fontSize: 24,
    lineHeight: 28,
  },

  /* Modal styles */
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "center",
    alignItems: "center",
  },
  chatModal: {
    width: "90%",
    maxHeight: "80%",
    backgroundColor: "#fff",
    borderRadius: 12,
    padding: 16,
  },
  closeButton: {
    marginTop: 16,
    backgroundColor: "#10B981",
    paddingVertical: 10,
    alignItems: "center",
    borderRadius: 8,
  },
});
Key points shown in the example
SafeAreaView is root with flex: 1 â€” ensures absolute positioning has a full canvas.
ScrollView contains the scrolling content.
FAB is placed after the ScrollView as a sibling so it remains fixed and visible.
elevation: 10 is set for Android; zIndex: 9999 for iOS. Use both.
Avoid parent styles like overflow: 'hidden' on the root or any ancestor that could clip the FAB.
Extra tips & gotchas
If your FAB still doesnâ€™t appear: inspect the view hierarchy (React Native Debugger or Flipper) â€” ensure the FAB is rendered and not covered by another view.
Touchable area small / not responding? Ensure nothing with pointerEvents: 'none' overlays it.
If you want the FAB to sit inside the SafeArea but outside content padding: still acceptable â€” just ensure itâ€™s sibling of scrollable content and not a descendant of the ScrollView.
If you need multiple z-ordered overlays: maintain consistent elevation ordering on Android; higher elevation draws on top.
For top-left on notched phones: using top: 12 inside SafeAreaView plus SafeAreaView itself usually handles insets. If you need exact insets, use react-native-safe-area-context and useSafeAreaInsets().
Why this differs from web CSS
React Native absolute positioning is similar, but stacking behavior differs:
iOS: zIndex controls stacking order
Android: elevation influences stacking and shadow; zIndex also works but elevation is the primary for drawing order
Parent clipping: RN parents can clip absolute children if overflow is set; check ancestors.
Thereâ€™s no CSS stacking context inheritance the way browsers have; you frequently must set both zIndex and elevation.