shared Schema

// The Job data sent from the frontend to /api/download
export interface DownloadJob {
  novel: NovelMetadata;
  chapters: Chapter[];
  fileType: 'epub' | 'pdf' | 'html';
}

export interface NovelMetadata {
  title: string;
  author: string;
  // NEW: The URL for the cover image, found by the scraper
  coverImageUrl?: string; 
  // NEW: The novel description, found by the scraper
  description?: string;
  // This is a client-side helper, not from the backend
  chapterCount?: number; 
}

export interface Chapter {
  title: string;
  url: string;
  // Content is not sent from the client, it's fetched by the server
}

// Data returned by the /api/analyze endpoint
export type AnalyzeResult = {
  novel: NovelMetadata;
  chapters: Chapter[];
};

server / scraper

import axios from 'axios';
import * as cheerio from 'cheerio';
import { NovelMetadata, Chapter, AnalyzeResult } from '../shared/schema';

// --- NEW: Smart Description Finder ---
/**
 * Tries to find the novel description using multiple patterns.
 * @param $ - Cheerio instance
 * @returns The found description, or an empty string
 */
function detectDescription($: cheerio.CheerioAPI): string {
  let description = '';

  // 1. Try JSON-LD first
  try {
    const jsonLd = $('script[type="application/ld+json"]').html();
    if (jsonLd) {
      const data = JSON.parse(jsonLd);
      if (data && data['@type'] === 'Book' && data.description) {
        description = data.description;
      }
    }
  } catch (e) {
    console.warn('[Desc] Failed to parse JSON-LD', e.message);
  }

  // 2. Try Meta Tags
  if (!description) {
    const selectors = [
      'meta[property="og:description"]',
      'meta[name="description"]',
      'meta[name="book-description"]',
    ];
    for (const selector of selectors) {
      const meta = $(selector).attr('content');
      if (meta) {
        description = meta;
        break;
      }
    }
  }

  // 3. Try Common Class/ID/Attribute Selectors
  if (!description) {
    const selectors = [
      '.description', '.book-description', '.synopsis', '.summary',
      '#description', '#synopsis', '[data-description]',
      '[class*="desc"]', '[class*="summary"]'
    ];
    for (const selector of selectors) {
      const el = $(selector).first().text();
      if (el) {
        description = el;
        break;
      }
    }
  }

  // 4. Fallback: First <p> near the title (if desperate)
  // This is less reliable and can be omitted if too noisy
  // if (!description) {
  //   description = $('.novel-title').closest('div').find('p').first().text();
  // }

  // Clean and truncate
  if (description) {
    return description.trim().replace(/\s+/g, ' ').substring(0, 500);
  }

  return '';
}

// --- NEW: Smart Cover Image Finder ---
/**
 * Tries to find the novel cover URL using multiple patterns.
 * @param $ - Cheerio instance
 * @param baseUrl - The base URL to resolve relative paths
 * @returns The absolute URL for the cover, or undefined
 */
function detectCoverImageUrl($: cheerio.CheerioAPI, baseUrl: string): string | undefined {
  let coverUrl = '';

  // 1. Try JSON-LD first
  try {
    const jsonLd = $('script[type="application/ld+json"]').html();
    if (jsonLd) {
      const data = JSON.parse(jsonLd);
      if (data && data['@type'] === 'Book' && data.image) {
        coverUrl = data.image;
      }
    }
  } catch (e) {
    console.warn('[Cover] Failed to parse JSON-LD', e.message);
  }

  // 2. Try Meta Tags
  if (!coverUrl) {
    const selectors = [
      'meta[property="og:image"]',
      'meta[property="twitter:image"]',
      'meta[name="image"]',
      'link[rel="image_src"]',
    ];
    for (const selector of selectors) {
      const meta = $(selector).attr('content');
      if (meta) {
        coverUrl = meta;
        break;
      }
    }
  }

  // 3. Try Common Class/ID Selectors
  if (!coverUrl) {
    const selectors = [
      '.cover img', '.book-cover img', '.novel-cover img',
      'img[class*="cover"]', 'img[id*="cover"]'
    ];
    for (const selector of selectors) {
      const img = $(selector).first().attr('src');
      if (img) {
        coverUrl = img;
        break;
      }
    }
  }

  // Resolve relative URLs
  if (coverUrl) {
    try {
      const url = new URL(coverUrl, baseUrl);
      return url.href;
    } catch (e) {
      console.error(`[Cover] Invalid cover URL found: ${coverUrl}`);
      return undefined;
    }
  }

  return undefined;
}

// --- NEW: Image Download Utility ---
/**
 * Downloads an image with retry logic and returns a Buffer.
 * @param url The image URL to download
 * @returns Buffer and content type, or undefined on failure
 */
export async function downloadImage(url: string): Promise<{ data: Buffer; contentType: string } | undefined> {
  if (!url) return undefined;
  
  let attempts = 0;
  while (attempts < 3) {
    try {
      const response = await axios.get(url, {
        responseType: 'arraybuffer',
        timeout: 15000,
        headers: {
          'Accept': 'image/jpeg,image/png,image/webp,*/*'
        }
      });

      const contentType = response.headers['content-type'];
      if (response.data && (contentType === 'image/jpeg' || contentType === 'image/png' || contentType === 'image/webp')) {
        console.log(`[Image] Downloaded ${url} (${contentType})`);
        return {
          data: response.data,
          contentType: contentType,
        };
      }
      console.warn(`[Image] Invalid content type: ${contentType}`);
      return undefined; // Not an image
      
    } catch (error) {
      attempts++;
      console.warn(`[Image] Download attempt ${attempts} failed for ${url}:`, error.message);
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
    }
  }
  
  console.error(`[Image] All download attempts failed for ${url}`);
  return undefined;
}

// --- analyzeUrl (Updated) ---
/**
 * Analyzes a novel's table of contents page.
 * @param url The URL of the novel's main page
 * @returns Novel metadata and a list of chapter URLs
 */
export async function analyzeUrl(url: string): Promise<AnalyzeResult> {
  const { data } = await axios.get(url, { timeout: 10000 });
  const $ = cheerio.load(data);
  const baseUrl = new URL(url).origin;

  // --- This query is an EXAMPLE. ---
  // --- You MUST update these selectors for your specific novel source(s). ---
  
  // Basic Metadata
  const title = $('h1.novel-title').text() || $('meta[property="og:title"]').attr('content') || $('title').text();
  const author = $('.author-name').text() || $('meta[name="author"]').attr('content') || 'Unknown Author';

  // NEW: Smart Detection
  console.log(`[Scrape] Detecting description for ${title}...`);
  const description = detectDescription($);
  console.log(`[Scrape] Detecting cover for ${title}...`);
  const coverImageUrl = detectCoverImageUrl($, url);

  const novel: NovelMetadata = {
    title: title.trim(),
    author: author.trim(),
    description,
    coverImageUrl,
  };

  // Chapter List
  const chapters: Chapter[] = [];
  // --- This query is an EXAMPLE. ---
  $('#chapter-list a, .chapter-list a, ul.chapters > li > a').each((i, el) => {
    const chapterTitle = $(el).text().trim();
    const chapterUrl = $(el).attr('href');

    if (chapterTitle && chapterUrl) {
      try {
        const fullUrl = new URL(chapterUrl, baseUrl);
        chapters.push({
          title: chapterTitle,
          url: fullUrl.href,
        });
      } catch (e) {
        console.warn(`[Scrape] Skipping invalid chapter URL: ${chapterUrl}`);
      }
    }
  });
  
  console.log(`[Scrape] Found ${chapters.length} chapters for ${novel.title}`);
  return { novel, chapters };
}

Generator

// The Job data sent from the frontend to /api/download
export interface DownloadJob {
  novel: NovelMetadata;
  chapters: Chapter[];
  fileType: 'epub' | 'pdf' | 'html';
}

export interface NovelMetadata {
  title: string;
  author: string;
  // NEW: The URL for the cover image, found by the scraper
  coverImageUrl?: string; 
  // NEW: The novel description, found by the scraper
  description?: string;
  // This is a client-side helper, not from the backend
  chapterCount?: number; 
}

export interface Chapter {
  title: string;
  url: string;
  // Content is not sent from the client, it's fetched by the server
}

// Data returned by the /api/analyze endpoint
export type AnalyzeResult = {
  novel: NovelMetadata;
  chapters: Chapter[];
};

home tsx

import { useState } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import { useForm } from 'react-hook-form';
import axios, { AxiosError } from 'axios';
import { AnalyzeResult, DownloadJob, NovelMetadata } from '../../shared/schema';

// Components (Assuming you have these)
import { Input } from '../components/ui/input';
import { Button } from '../components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';
import { MetadataDisplay } from '../components/metadata-display';
import { DownloadProgress } from '../components/download-progress'; // Assuming this component exists
import { Loader2, AlertCircle } from 'lucide-react';

// Zod schema for form validation
const formSchema = z.object({
  url: z.string().url({ message: 'Please enter a valid URL.' }),
});

export default function HomePage() {
  const [url, setUrl] = useState('');
  const [fileType, setFileType] = useState<'epub' | 'pdf' | 'html'>('epub');

  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(formSchema),
  });

  // --- LSP FIX 1: Provide full types for useQuery ---
  // This tells useQuery what to expect for success (AnalyzeResult) and error (AxiosError).
  const { data: analysis, error: analysisError, isFetching: isAnalyzing, refetch: analyzeUrl } = useQuery<AnalyzeResult, AxiosError<{ error: string }>>({
    queryKey: ['analyzeUrl', url],
    queryFn: async () => {
      const { data } = await axios.post('/api/analyze', { url });
      return data;
    },
    enabled: false, // Only run when `analyzeUrl` is called
    retry: 1,
  });

  // --- LSP FIX 2: Provide full types for useMutation ---
  // <void> = return type of mutationFn
  // <AxiosError> = error type
  // <DownloadJob> = variables type (what we pass to mutate)
  const { mutate: startDownload, isPending: isDownloading } = useMutation<void, AxiosError, DownloadJob>({
    mutationFn: async (job) => {
      // Use streaming download
      const response = await axios.post('/api/download', job, {
        responseType: 'blob', // Expect a file blob back
      });
      
      // Create a URL for the blob and trigger download
      const blob = new Blob([response.data], { type: response.headers['content-type'] });
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      
      // Get filename from content-disposition header
      const contentDisposition = response.headers['content-disposition'];
      let filename = `${job.novel.title}.${job.fileType}`; // fallback
      if (contentDisposition) {
        const filenameMatch = contentDisposition.match(/filename="?([^"]+)"?/);
        if (filenameMatch.length > 1) {
          filename = filenameMatch[1];
        }
      }
      
      link.href = downloadUrl;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(downloadUrl);
    },
    onError: (err) => {
      console.error('Download failed', err);
      // You would show a toast or error message here
    },
  });

  const onAnalyzeSubmit = (data: { url: string }) => {
    setUrl(data.url);
    // useQuery's refetch is stable, no hook rule violation
    analyzeUrl();
  };

  const onDownloadClick = () => {
    // --- LSP FIX 3: Handle undefined data ---
    // Ensure `analysis` is defined before trying to use it.
    if (!analysis) return;

    const job: DownloadJob = {
      novel: analysis.novel,
      chapters: analysis.chapters,
      fileType: fileType,
    };
    startDownload(job);
  };

  // Combine novel metadata with client-side chapter count
  const displayMetadata: NovelMetadata | undefined = analysis ? {
    ...analysis.novel,
    chapterCount: analysis.chapters.length,
  } : undefined;

  return (
    <div className="container mx-auto max-w-lg p-4">
      <h1 className="text-3xl font-bold text-center mb-6">Web Novel Converter</h1>

      <form onSubmit={handleSubmit(onAnalyzeSubmit)} className="space-y-4">
        <div className="flex gap-2">
          <Input
            placeholder="Enter novel URL..."
            {...register('url')}
            className="flex-1"
          />
          <Button type="submit" disabled={isAnalyzing}>
            {isAnalyzing ? <Loader2 className="animate-spin" /> : 'Analyze'}
          </Button>
        </div>
        {errors.url && <p className="text-red-500 text-sm">{errors.url.message}</p>}
      </form>

      {analysisError && (
        <div className="mt-4 text-red-500 flex items-center gap-2">
          <AlertCircle className="w-5 h-5" />
          <p>Error: {analysisError.response?.data?.error || analysisError.message}</p>
        </div>
      )}

      {/* --- LSP FIX 4: Conditional rendering based on `displayMetadata` --- */}
      {displayMetadata && !isAnalyzing && (
        <div className="mt-6 space-y-4">
          <MetadataDisplay novel={displayMetadata} />
          
          <div className="flex gap-2">
            <Select onValueChange={(v: 'epub' | 'pdf' | 'html') => setFileType(v)} defaultValue={fileType}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Format" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="epub">EPUB</SelectItem>
                <SelectItem value="pdf">PDF</SelectItem>
                <SelectItem value="html">HTML</SelectItem>
              </SelectContent>
            </Select>
            <Button onClick={onDownloadClick} disabled={isDownloading} className="flex-1">
              {isDownloading ? <Loader2 className="animate-spin" /> : `Download as ${fileType.toUpperCase()}`}
            </Button>
          </div>
        </div>
      )}

      {isDownloading && (
        <div className="mt-4">
          <DownloadProgress
            title={analysis?.novel.title || "Download"}
            progress={0} // You would need a way to track progress, but streaming makes this hard.
            status="Generating file... Please wait."
          />
        </div>
      )}
    </div>
  );
}

metadata

import React from 'react';
import { NovelMetadata } from '../../shared/schema';

interface MetadataDisplayProps {
  // The novel prop now includes the new fields
  novel: NovelMetadata;
}

// FIX: Removed 'export' from here to make it a default export below
const MetadataDisplay: React.FC<MetadataDisplayProps> = ({ novel }) => {
  return (
    <div className="flex items-start gap-4 p-4 bg-gray-800 rounded-lg">
      <img
        // NEW: Use the coverImageUrl from the metadata
        src={novel.coverImageUrl}
        alt="Novel Cover"
        className="w-20 h-28 object-cover rounded flex-shrink-0"
        // Fallback placeholder
        onError={(e) => (e.currentTarget.src = 'https://placehold.co/80x112/374151/9ca3af?text=N/A')}
      />

      {/* FIX: Add min-w-0 to allow text to wrap properly in flexbox */}
      <div className="flex-1 min-w-0">
        <p className="font-semibold text-base text-white break-words line-clamp-2">
          {novel.title}
        </p>
        <p className="text-sm text-gray-400 mt-1">{novel.author}</p>
        <p className="text-sm text-gray-500 mt-1">{novel.chapterCount} chapters</p>
        
        {/* NEW: Display the description if it exists */}
        {novel.description && (
           <p className="text-xs text-gray-400 mt-2 line-clamp-3">
             {novel.description}
           </p>
        )}
      </div>
    </div>
  );
};

// FIX: Changed to a default export to resolve the import/export mismatch error
export default MetadataDisplay;

Gemini Chat:

This is a significant and excellent set of upgrades. You're moving from a simple content grabber to a full-fledged eBook generator. The "smart" detection for covers and descriptions is a huge user-facing improvement, and fixing the LSP errors is critical for stability.

I've analyzed your requirements and prepared the modifications for all requested files.

Here is the plan:

shared/schema.ts: Add description and coverImageUrl to NovelMetadata.

server/scraper.ts:

Create a new, robust downloadImage utility with retry logic.

Implement detectCoverImageUrl using your multi-pattern strategy (JSON-LD, meta, tags).

Implement detectDescription using your multi-pattern strategy.

Update analyzeUrl to use these new functions and return the new metadata.

server/generator.ts:

Modify streamEpub to download the cover, create a dedicated cover.xhtml page, add the image to the archive, and update the manifest/spine.

Modify streamPdf to download the cover and place it on the first page of the document, before the title page.

client/src/pages/home.tsx: Fix the likely LSP errors. These are almost always caused by:

Type mismatches on useQuery or useMutation (e.g., not passing the correct types).

Incorrectly handling the data state (e.g., data being undefined on first render).

I will provide a clean, type-safe version that correctly handles query/mutation states.

client/src/components/metadata-display.tsx: Update this component to use the new coverImageUrl from the analyzeUrl query data for the preview.

Here are the modified files:

1. Schema (Updated)
I've added the optional description and coverImageUrl fields to the metadata. This is what analyzeUrl will now return.

2. Scraper (Enhanced)
This file has the most changes. It now includes the "smart" detection functions you specified and a robust image downloader.
server/scraper.ts
Nov 29, 8:17 PM

Open

3. Generator (Updated)
The generator now downloads the cover and prepends it to both EPUB and PDF formats.

4. home.tsx (LSP Errors Fixed)
I've fixed the common LSP errors by properly typing useQuery and useMutation, handling undefined data, and ensuring correct hook usage.
client/src/pages/home.tsx
Nov 29, 8:17 PM

Open

5. metadata-display.tsx (Updated)
This component is now updated to use the coverImageUrl and description from the NovelMetadata prop.
client/src/components/metadata-display.tsx
Nov 29, 8:22 PM


User Note:

be sure to integrate this into the code if it's better, or improvise to be sure there's no error
